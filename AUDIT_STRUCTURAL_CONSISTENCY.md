# Structural Consistency Audit Report

**Date:** 2025-01-XX  
**Scope:** Initiative IDs, blocker mappings, roadmap references, dependency graph, parallel execution groups, CAF/ALZ taxonomy, Learn references  
**Branch:** dev  
**Constraint:** No scoring math changes. No content rewrite. Structural consistency only.

---

## Summary

**8 findings identified. 3 Critical, 3 High, 2 Medium.**

All findings are structural join-stability issues — mismatched keys, duplicate data, taxonomy drift, and non-deterministic ID generation. Scoring math is unaffected.

---

## Finding F1 — Initiative IDs Are Ordinal, Not Hash-Derived (Critical)

**Location:** `ai/engine/reasoning_engine.py` line 130, `ai/prompts/roadmap.txt`  
**Symptom:** Initiative IDs are `INIT-001` through `INIT-006`, generated by the LLM as sequential ordinals.  
**Impact:** If the LLM reorders initiatives between runs (e.g., swaps INIT-002 and INIT-003), all downstream joins break — blockers reference wrong initiatives, dependency graph is wrong, parallel groups are wrong.  
**Rule violated:** "Initiative IDs must be derived from control clusters (hash of control set). Never ordinally assigned."

**Fix:** After extracting initiatives from LLM output, compute `INIT-{sha256(sorted(controls)).hexdigest()[:8]}` for each initiative. Build old→new mapping. Walk the entire output tree and remap all INIT-NNN references.

---

## Finding F2 — LLM Blocker→Initiative Mapping Is Wrong for 4/5 Blockers (High)

**Location:** `ai.enterprise_scale_readiness.blockers[].resolving_initiative`  
**Symptom:** The LLM assigned sequential INIT-NNN values that don't match the actual initiative purpose:

| Blocker Category | LLM resolving_initiative | Actual Initiative | Correct Initiative |
|---|---|---|---|
| Governance | INIT-001 | MG hierarchy | INIT-001 ✓ |
| Networking | INIT-002 | Centralize diagnostics | INIT-004 (hub-spoke) ✗ |
| Security | INIT-003 | Governance policies | INIT-005 (Defender) ✗ |
| Identity | INIT-004 | Hub-spoke network | INIT-006 (identity logging) ✗ |
| Management | INIT-005 | Defender coverage | INIT-002 (diagnostics) ✗ |

**Mitigation:** The deterministic `blocker_initiative_mapping` (from `decision_impact.py`) already fixes this at runtime via category→section→initiative matching. The report renderer (`render.py`) uses the deterministic model. However, anyone reading `enterprise_scale_readiness.blockers` directly gets wrong data.

**Fix:** After ID remapping (F1), also patch `enterprise_scale_readiness.blockers[].resolving_initiative` from the deterministic mapping.

---

## Finding F3 — Dependency Graph Uses Action TEXT Keys, Not Initiative IDs (High)

**Location:** `ai.transformation_roadmap.dependency_graph`, `ai._raw.roadmap.dependency_graph`  
**Symptom:** The LLM dependency_graph uses full action text strings for `depends_on`:
```json
{
  "action": "Apply baseline governance policies...",
  "depends_on": ["Establish platform and landing zone management group hierarchy..."]
}
```
No `initiative_id` field. Joins by initiative ID are impossible.

**Mitigation:** The deterministic `dependency_graph_model` (from `dependency_engine.py`) provides correct ID-keyed dependencies. Report renderer uses the deterministic model.

**Fix:** (a) Update `roadmap.txt` prompt to include `initiative_id` in dependency_graph entries. (b) Post-LLM normalizer adds `initiative_id` to each dep graph entry and converts `depends_on` to initiative IDs by cross-referencing roadmap_30_60_90 action→initiative_id mapping.

---

## Finding F4 — Three Taxonomy Systems With No Canonical Mapping (High)

**Location:** Cross-module  
**Symptom:** Three different vocabulary systems in use:

| System | Values | Used In |
|---|---|---|
| KG `affects` disciplines | identity, security, network, management, automation, organization, cost | `graph/controls.json` |
| Control `section` / `alz_design_area` | 8 official ALZ design area names | Assessment results, `decision_impact.py` |
| Initiative `caf_discipline` | Govern, Manage, Ready, Secure, Adopt | LLM initiative output |

No bidirectional mapping exists between these systems. The `_BLOCKER_CATEGORY_TO_SECTIONS` dict in `decision_impact.py` is the only bridge, and it maps a 4th vocabulary (blocker categories) to ALZ design area names.

**Fix:** Create `schemas/taxonomy.py` — a locked canonical mapping table with:
- `ALZ_DESIGN_AREAS`: The 8 official names
- `KG_DISCIPLINE_TO_ALZ`: Maps KG discipline → ALZ design area
- `BLOCKER_CATEGORY_TO_ALZ`: Maps blocker short categories → ALZ design area
- `CAF_PHASES`: The CAF lifecycle phases

---

## Finding F5 — `alz_design_area` Field Missing From Initiative Output (Medium)

**Location:** `ai.initiatives[]`, `ai._raw.roadmap.initiative_execution_plan[]`  
**Symptom:** The `roadmap.txt` prompt schema includes `alz_design_area` in `initiative_execution_plan`, but the LLM omits it from output. Initiatives have `caf_discipline` (lifecycle phase) but no ALZ design area mapping.

**Fix:** Post-LLM normalizer infers `alz_design_area` from initiative controls' `section` field using majority vote. Added during ID remapping pass.

---

## Finding F6 — Learn References Have Empty URLs (Medium)

**Location:** `ai.initiatives[].learn_references[].url`, `ai._raw.grounded_refs[].references[].url`  
**Symptom:** ALL learn_references have `url: ""` (empty string). Titles and excerpts are populated from MCP retrieval, but URLs are not passed through.

**Impact:** Report cannot link to actual Microsoft Learn pages.

**Fix:** This is an MCP retriever issue (data quality), not a structural join issue. Noted but not addressed in this structural audit. Filed for separate investigation.

---

## Finding F7 — Initiative/Roadmap Data Duplicated in 4+ Locations (Informational)

**Location:** Full output JSON  
**Symptom:** Same data exists in multiple paths:

| Data | Locations |
|---|---|
| Initiatives | `transformation_plan.initiatives`, `ai.initiatives`, `ai._raw.roadmap.initiative_execution_plan`, `ai.grounding_context.initiatives` |
| Roadmap 30/60/90 | `transformation_plan.roadmap.roadmap_30_60_90`, `transformation_roadmap.roadmap_30_60_90`, `ai.transformation_roadmap.roadmap_30_60_90`, `ai._raw.roadmap.roadmap_30_60_90` |
| Dependency graph | `transformation_plan.roadmap.dependency_graph`, `transformation_roadmap.dependency_graph`, `ai.transformation_roadmap.dependency_graph`, `ai._raw.roadmap.dependency_graph` |

**Impact:** ID remapping must cover ALL locations, or stale ordinal IDs leak.

**Fix:** The ID rewriter walks the entire output tree to ensure no stale IDs remain.

---

## Finding F8 — No Validation for Duplicate Control-to-Initiative Mapping (Low)

**Location:** `engine/dependency_engine.py` `_map_controls_to_initiatives()`  
**Symptom:** Uses first-match (`if ctrl_id not in mapping`). Currently safe — all controls are unique across initiatives. But if the LLM assigns a control to multiple initiatives, the dependency graph silently drops the second mapping.

**Fix:** Add a warning log when a control appears in multiple initiatives.

---

## Proposed Deterministic Remapping

### 1. Hash-Based Initiative IDs (`engine/id_rewriter.py`)
- After LLM returns `initiative_execution_plan`, compute: `INIT-{sha256('|'.join(sorted(controls))).hexdigest()[:8]}`
- Build `old_id → new_id` mapping
- Walk ALL initiative/roadmap/blocker/dep-graph/parallel-group structures and remap
- Store mapping in output for traceability

### 2. Locked Canonical ALZ Mapping (`schemas/taxonomy.py`)
- Single source of truth for all 8 ALZ design areas
- Bidirectional lookup: KG discipline ↔ ALZ design area
- Blocker category → ALZ design area
- Used by `decision_impact.py`, ID rewriter, and validators

### 3. Dependency Graph Normalization
- Add `initiative_id` to each dep graph entry (from roadmap_30_60_90 cross-ref)
- Convert text-based `depends_on` to initiative ID arrays
- Keeps original `action` text for human readability

### 4. Post-Remap Blocker Patching
- After deterministic `resolve_blockers_to_initiatives()`, patch `enterprise_scale_readiness.blockers[].resolving_initiative` with correct values

---

## Join Stability Confirmation

After implementing the above fixes, joins are stable because:

1. **Deterministic IDs:** Same control set → same hash → same ID across runs, regardless of LLM ordering
2. **Single-pass remapping:** All references rewritten from one `id_map` — no partial remaps
3. **Canonical taxonomy:** `schemas/taxonomy.py` is the locked reference — eliminates free-text variance
4. **Deterministic models preferred:** Report renderer and downstream consumers use `dependency_graph_model`, `blocker_initiative_mapping`, `deterministic_trajectory` — all computed from post-remap data
5. **Tree-walker coverage:** ID rewriter walks entire output dict — no stale ordinal IDs in any path (F7 mitigated)
